#!/usr/bin/env bash

debug=false

# view-token
#
# This script can decode and show macaroons and OIDC (JWT) tokens.

usage() {
  cat <<-EOF
	view-token - a script to view the properties of macaroons and OIDC tokens.

	Arguments:

	<filename>     - file containing a token. Can be a plain text file with the bare token,
	                 or an Rclone config file. In that case, view-token will search for
	                 a line containing "bearer_token" and decode the value.

	<no filename>  - view-token will look for environment variable BEARER_TOKEN
	                 and decode its value.

	--debug        - Show additional information.

	EOF
}



view_token() {
  local token="$1"
  local token_debug_info="$2"

  echo "$token_debug_info"

  # Determine token type (JWT or Macaroon)
  if [[ "$token" =~ ^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$ ]]; then
    # JWT / OIDC token.

    # Get payload with the token properties.
    payload=$(echo "$token" | cut -d "." -f2 | base64 -d 2>/dev/null | tr -d '\n')

    # Check if decoding succeeded
    if [ -z "$payload" ]; then
      echo "Invalid token: cannot decode payload"
      return 1
    fi

    # Print JWT/OIDC token with human readable timestamps
    echo "Token is an OIDC token."
    echo "$payload" | jq '. | .exp |= todate | .nbf |= todate | .iat |= todate'
  else
    # Not an OIDC token; probably a Macaroon
    # We use grep with --text to avoid a "Binary file" message.
    macaroon_decoded=$(echo "$token" \
                       | base64 -d 2>/dev/null \
                       | awk '{print substr($0, 5)}' 2>/dev/null \
                       | grep --text -v 'signature' \
                       | tr -d '\0')

    # Check if decoding succeeded
    if [ -z "$macaroon_decoded" ]; then
      echo "Invalid macaroon: cannot decode"
      return 1
    fi

    echo "Token is a macaroon."
    echo -e "\033[34m\n$macaroon_decoded\n\033[0m" | sed -e 's/^/  /'
  fi
}


validate_expiration_timestamp () {
  local exp_unix="$1"           # Expiration timestamp (unix format)
  local min_valid_time=60       # Token should be valid for more than this many seconds

  # Do we actually have an expiration timestamp?
  if [ -z "$exp_unix" ] || ! [[ "$exp_unix" =~ ^[0-9]+$ ]]; then
    echo 1>&2 "ERROR: Invalid token: missing or invalid expiration field"
    return 1
  fi

  # Get the current time in seconds since epoch
  now=$(date +%s)

  # Check if the token is expired
  if [ "$now" -ge "$exp_unix" ]; then
    echo 1>&2 "Token has expired $(( now - exp_unix )) seconds ago."
    return 1
  fi

  # Check if the token is about to expire
  if [ "$now" -ge "$(( exp_unix - min_valid_time ))" ]; then
    echo 1>&2 "Warning: Token will expire in $(( exp_unix - now )) seconds."
    return 1
  fi

  # If we get here, the expiration timestamp should be valid.
  return 0
}


check_token() {
  local token="$1"
  local token_debug_info="$2"

  # Determine token type (JWT or Macaroon)
  if [[ "$token" =~ ^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$ ]]; then
    # JWT / OIDC token
    payload=$(echo "$token" | cut -d "." -f2 | base64 -d 2>/dev/null | tr -d '\n')

    # Check if decoding succeeded
    if [ -z "$payload" ]; then
      echo 1>&2 "ERROR: Invalid token: cannot decode payload"
      return 1
    fi

    # Show JWT / OIDC token
    echo "$payload" | jq '. | .exp |= todate | .nbf |= todate | .iat |= todate'

    # Extract expiration time (exp) from payload
    exp_unix=$(echo "$payload" | jq -r '.exp' 2>/dev/null)

    # Fail if the token has (almost) expired
    if ! validate_expiration_timestamp "$exp_unix" "$token_debug_info" ; then
      echo 1>&2 "JWT/OIDC token is no longer valid."
      return 1
    fi

    # If we get here, it means we have a valid OIDC token.
    "JWT / OIDC token is still valid"
    return 0

  else
    # Macaroon Token (assume it's base64 encoded)
    # We use grep with --text to avoid a "Binary file" message.
    macaroon_decoded=$(echo "$token" \
                       | base64 -d 2>/dev/null \
                       | awk '{print substr($0, 5)}' 2>/dev/null \
                       | grep --text -v 'signature' \
                       | tr -d '\0')

    # Check if decoding succeeded
    if [ -z "$macaroon_decoded" ]; then
      echo 1>&2 "ERROR: Invalid token: cannot decode"
      return 1
    fi

    # Show the macaroon
    echo -e "\033[34m\n$macaroon_decoded\n\033[0m" | sed -e 's/^/  /'

    # Extract expiration time (before) using regex
    exp=$(echo "$macaroon_decoded" | grep -o 'before:[0-9T:\.-]*Z' | sed -e 's/before://')

    # Validate expiration field
    if [ -z "$exp" ]; then
      echo 1>&2 "ERROR: invalid macaroon: missing 'before' field"
      return 1
    fi

    # Convert expiration time to unix time (seconds since epoch)
    case $OSTYPE in
      darwin* )  exp_unix=$(date -u -j -f "%Y-%m-%dT%H:%M:%S" "${exp:0:19}" +"%s" 2>/dev/null)  ;;
            * )  exp_unix=$(date -d "$exp" +%s 2>/dev/null)  ;;
    esac

    if [ -z "$exp_unix" ]; then
      echo 1>&2 "ERROR: invalid macaroon: unable to parse 'before' timestamp"
      return 1
    fi

    # Fail if the token has (almost) expired
    if ! validate_expiration_timestamp "$exp_unix" "$token_debug_info" ; then
      echo 1>&2 "Macaroon is no longer valid."
      return 1
    fi

    # If we get here, it means we have a valid macaroon.
    echo "Macaroon is still valid"
    return 0
  fi
}


if [ -n "$1" ] ; then
  tokenfile="$1"
  echo "Token source: $tokenfile"
  #
  # Let's check the file with the token.
  if ! [ -f "$tokenfile" ] ; then
    echo 1>&2 "ERROR: specified tokenfile '$tokenfile' does not exist."
    exit 1
  fi
  #
  # First, we assume the tokenfile is an Rclone config file.
  token=$(sed -n 's/^bearer_token *= *//p' "$tokenfile")
  if [ "$(wc -l <<<"$token")" -gt 1 ] ; then
    echo 1>&2 "ERROR: file '$tokenfile' contains multiple tokens. Can't determine which one to show."
    exit 1
  fi
  # If it was not an rclone config file, it may be a
  # plain text file with only the token.
  if [ -z "$token" ] ; then
    token=$(head -n 1 "$tokenfile")
  fi

else
  if [ -n "$BEARER_TOKEN" ] ; then
    token="$BEARER_TOKEN"
    echo "Token source: BEARER_TOKEN variable"
  else
    echo "No tokenfile specified, and BEARER_TOKEN is empty. Nothing to do."
    exit 1
  fi
  # read BEARER_TOKEN
fi

#view_token  "$token" || exit 1
check_token "$token" || exit 1
